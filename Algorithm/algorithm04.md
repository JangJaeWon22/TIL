# Algorithm TIL

## 1. 최소힙 - 백준 1927 문제

#### 문제

널리 잘 알려진 자료구조 중 최소 힙이 있다. 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

배열에 자연수 x를 넣는다.

배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.

프로그램은 처음에 비어있는 배열에서 시작하게 된다.

#### 입력

첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. x는 231보다 작은 자연수 또는 0이고, 음의 정수는 입력으로 주어지지 않는다.

#### 출력

입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.

#### 풀이

- 파이썬에는 heapq라는 내장 모듈이 있다. 이걸 활용해서 만들면 된다!
- 최소힙을 구하는데 특화 되어 있다.
- 최대힙은 2번에서 설명하겠다.

```python
import sys
import heapq

input = sts.stdin.readline

n = int(input())
heap = []

for _ in range(n):
    a = int(input())
    if a == 0:                              # 0을 외치면 가장 작은 값을 출력 or 비어있을 때 0 출력
        if not heap:                        # heap이 비어있을 때
            print(0)
        else:                               # heap이 비어있지 않을 경우
            print(heapq.heappop(heap))      # 가장 작은 값을 pop 으로 뽑으면서 print, 삭제 진행
    else:
        heapq.heappush(heap, a)             # 0이 아닌 다른 수를 외칠 경우 push

```

- 모듈을 사용하면 쉽게 처리가 된다.
- 그냥 외웠다.... 처음 보고 완전 이진트리를 모듈로 만들어진 python 만세...

## 2. 최대힙 - 백준 11279 문제

#### 문제

널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

배열에 자연수 x를 넣는다.

배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.

프로그램은 처음에 비어있는 배열에서 시작하게 된다.

#### 입력

첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.

#### 출력

입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.

#### 풀이

- 최소 힙의 반대라고 생각하자.
- 반대? ----> 그것은 그냥 입력받은 값을 \* -1 해주면 된다..

```python
import sys
import heapq

input = sts.stdin.readline

n = int(input())
heap = []

for _ in range(n):
   a = int(input())
   b = b * -1
   if b == 0:                              # 0을 외치면 가장 작은 값을 출력 or 비어있을 때 0 출력
       if not heap:                        # heap이 비어있을 때
           print(0)
       else:                               # heap이 비어있지 않을 경우
           print(heapq.heappop(heap) * -1)      # 가장 작은 값을 pop 으로 뽑으면서 print, 삭제 진행
   else:
       heapq.heappush(heap, b)             # 0이 아닌 다른 수를 외칠 경우 push

```

- 1번 문제의 그냥 정반대 문제..
- b를 선언해서 그냥 -1 해버리고 pop 부분도 -1로 저장 되어있던 부분을 또 -1 곱해주면 자연수가 된다.

---

## 3. 회전하는 큐 - 백준 2021 문제

#### 문제

널리 잘 알려진 자료구조 중 최소 힙이 있다. 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

배열에 자연수 x를 넣는다.

배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.

프로그램은 처음에 비어있는 배열에서 시작하게 된다.

#### 입력

첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다.

다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다.

만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다.

x는 231보다 작은 자연수 또는 0이고, 음의 정수는 입력으로 주어지지 않는다.

#### 출력

입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.

#### 풀이

- 배열에서 뽑을 숫자가 왼쪽에 가까우면 왼쪽으로 나오는 숫자를 오른쪽으로 옮긴 후 해당 숫자 뽑고
- 배열에서 뽑을 숫자가 오른쪽에 가까우면 오른쪽으로 나오는 숫자를 왼쪽으로 옮긴 후 해당 숫자를 뽑는다
- 오른쪽에서 가까운지, 왼쪽에서 가까운지는 총 배열의 길이 / 2 해서 적은 값이 더 가깝다.

```python
if queue.index(i) < len(queue)/2:
    queue.append(queue.popleft())
else:
    queue.appendleft(queue.pop())
```

- 코드

```python
from collections import deque
import sys
input = sys.stdin.readline

n, m = map(int, input().split())    # 큐의 크기 n과 뽑아내려고 하는 수의 개수 m을 입력값으로 받기
d = list(map(int, input().split()))  # 뽑아내려는 수의 위치를 입력값으로 받기
queue = deque([i for i in range(1, n+1)])  # deque([1, 2, 3,...,n])

count = 0
for i in d:  # 뽑아내려는 수의 위치 하나씩 반복문 돌리기
    while True:     # 뽑을 때까지 계속 돌리기
        if queue[0] == i:  # dq의 첫인덱스가 뽑아내려는 수의 위치와 같다면 1번 수행
            queue.popleft()
            break
        else:
            # 뽑아내려는 수의 위치 인덱스가 dq의 길이를 반으로 나눈것보다 작을때는 왼쪽으로 움직여야 최소
            if queue.index(i) < len(queue)/2:
                while queue[0] != i:   # dq의 첫번째 인덱스가 i와 같아질때까지 반복
                    queue.append(queue.popleft())
                    count += 1
            else:   # 뽑아내려는 수의 위치 인덱스가 dq의 길이를 반으로 나눈것보다 클때는 오른쪽으로 움직여야 최소
                while queue[0] != i:
                    queue.appendleft(queue.pop())
                    count += 1
print(count)

```

---

## 4. 기능개발 - 프로그래머스

#### 문제 설명

프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

#### 제한 사항

- 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.

- 작업 진도는 100 미만의 자연수입니다.

- 작업 속도는 100 이하의 자연수입니다.

- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

####입출력 예

|progresses|speeds|return|
|:--||:--||:--|
|[93, 30, 55]|[1, 30, 5]|[2, 1]|
|[95, 90, 99, 99, 80, 99]|[1, 1, 1, 1, 1, 1]|[1, 3, 2]|

입출력 예 설명

##### 입출력 예 #1

첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.

두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.

세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.

따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.

##### 입출력 예 #2

모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.

따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.

#### 풀이

- day를 증가 시키면서 기능이 100이 되었을 경우 pop 해버린다.
- 100이 되었을 경우 해당 숫자를 pop 했는데 다음꺼도 100이라서 pop 해줘야됨.
- 하지만 다음 숫자를 확인결과, 100 보다 작을 경우에는 카운트를 answer에 저장하고 초기화 해줘야됨.

```python

def solution(progresses, speeds):
    answer = []
    day = 0
    count = 0

    while progresses:                                   # progresses가 빌 때까지 반복
        if progresses[0] + day * speeds[0] >= 100:      # 현재 개발율 + (개발속도  * 날짜) >= 100 ==>> 즉 100이 되었을 경우
            progresses.pop(0)                           # progresses 의 1번째 정수 뽑아냄
            speeds.pop(0)                               # speeds 의 1번째 정수 뽑아냄
            count += 1                                  # 뽑아낸 기능의 갯수
        else:
            if count > 0:            # 뽑아낸 기능의 갯수가 있을 경우 --> 왜 else에 있는가 하면, 위의 if에 있을경우는 연속적으로 계속 100이 된것을 뽑기 위해서 만든 if문
                answer.append(count) # 그 카운트를 고스란히 answer에 담아준다.
                count = 0            # 원하는 항목 한개 담았으니 다시 초기화!!
            day += 1                 # else 문에 들어왔을 경우 day를 증가 ( 위의 if문에 상관안한다)

    answer.append(count)             # ** 중요... 마지막 카운트는 저장 안되길래 마지막꺼 저장할려고 끼워 넣음...
    return answer

```

- 헷갈렸다. 날짜를 구해서 뽑는 건 좋은데 어떤 타이밍에 뽑고 어떤 타이밍에 초기화 해야되는지,
- answer에 count를 저장 시켜주는 타이밍까지,,, 길이가 무조건 같지 않다.. 어떤 날짜에 몇개를 뽑아 내는지가 중요했기때문에..
