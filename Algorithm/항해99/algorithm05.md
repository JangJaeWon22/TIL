# Algorithm TIL

## 크레인 인형뽑기 - 프로그래머스

### 문제 설명

게임개발자인 "죠르디"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.
"죠르디"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.

게임 화면은 "1 x 1" 크기의 칸들로 이루어진 "N x N" 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다.

만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.

크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

### [제한사항]

board 배열은 2차원 배열로 크기는 "5 x 5" 이상 "30 x 30" 이하입니다.

board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.

0은 빈 칸을 나타냅니다.

1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.

moves 배열의 크기는 1 이상 1,000 이하입니다.

moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

### 입출력 예

| board                                                        | moves             | result |
| ------------------------------------------------------------ | ----------------- | ------ |
| [0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] | [1,5,3,5,1,2,1,4] | 4      |

### 입출력 예 #1

인형의 처음 상태는 문제에 주어진 예시와 같습니다.

크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후,
상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.

### 풀이

- 입력받은 보더 자체를 맨 처음 줄 그다음 2번째 줄 .. 5번째 줄로 인식
- moves에 따라 1이면 index = 1 인 곳에서 가장 위에서 부터 board[0]을 비교 해서 0이 아닌 자연수 일 경우 pop
- 그 후 stack에 담고
- stack[-1] == stack[-2] 일 경우 stack[:-2] 까지만 저장(-1,-2 번째는 pop 해버림)
- pop가 끝나면 지워진 자연수의 갯수가 +2 되도록 처리하면 된다.

```python
def solution(board, moves):
   # 결과값을 담을 stack이라는 공간 마련
   stack = []
   # 지워 질때 마다 +2 해줘야됨 - 초기 설정
   answer = 0

   # move는 인덱스의 위치만 설정
   for move in moves:
       # move가 1일 경우는 board의 0번째로 위에서 부터 자연수가 나올때까지 돌아야됨
       index = move - 1
       # row_info는 board 5개를 위에서부터 0이 아닌 경우를 찾아봄
       for row_info in board:
           if row_info[index] != 0:
               # 0 이 아니면 입력받은 숫자를 stack에 박아둠
               stack.append(row_info[index])
               # 인형을 뽑았으니 0으로 바꿔줘서 다음번 for문이 돌 때 뽑을 인형이 없는걸로 함.
               row_info[index] = 0
               # 이제 stack의 -1, -2 번째를 비교하고 같으면 뽑아줘야됨
               # 단, 초기 설정의 경우 빈 배열이기 때문에 비교할 숫자가 2개는 있어야됨 그래서 len(stack) > 1
               if len(stack) > 1 and stack[-1] == stack[-2]:
                   # 찾았으면 카운트 2개 더해줘야지!
                   answer += 2
                   # 그리고 pop 2번 해서 지워야됨. [:-2]를 해서 2줄 쓸꺼 한줄로 바꿈 ㅋ
                   stack = stack[:-2]
               break
   return answer
```

- 처음 board에서 인형을 따로 표시를 해야되나라는 멍청한 고민을 했다.
- 근데 몇번이고 읽어보니깐 받는 board에 표시가 되어 있었다. 인형 종류까지는 오버지...
- 그래서 차근차근 문제도 보면서 해설을 봤다.
- 안보고 짠게 아니라 완벽하지는 않지만, 다음엔 맞출 수 있다 라고 생각한다.

---

## 2. ATM - 백준 11399 문제

### 문제

인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.

사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.

줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.

줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)

### 출력

첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.

### 풀이

- 최솟값을 출력 하는 문제
- 해당 되는 인덱스 번호와 이전의 인덱스 번호들의 합을 구한 뒤 총합이 제일 적은 걸 뽑아내야됨
  - arr의 인덱스가 총 3개 일때
  - (index[0]) + (index[0] + index[1]) + (index[0] + index[1] + index[2])
  - 위의 식의 합계가 제일 적을 경우를 추려야됨
- 브리디 알고리즘이라고 한다.. -- 추가 공부 필요(뭔지 모름)

```python
# 규칙
# x =[1, 2, 3, 4, 5]
# 풀이: [1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5] => sum[1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5] => answer: 35
#           1,    (1)+ 2,     (1+2)+ 3,   (1+2+3)+ 4, (1+2+3+4)+ 5
# 정리: [ x[0], (x[0]+x[1]), (x[1]+x[2]), (x[1]+ x[2]), (x[1] + x[2]) ]

import sys
input = sys.stdin.readline

n = int(input())
x = list(map(int, input().split()))
# 정렬의 이유
# [1, 2, 3, 4, 5]
# -> [1, 3, 6, 10, 15] => sum : 35
# [5, 4, 3, 2, 1]
# -> [5, 9, 12, 14, 15] => sum : 55
# 결론 작은 순서대로 정렬을 하면 최솟값이 낮아짐

x.sort()

# 1부터 시작 이유 ----> 0번째 인덱스는 앞에 아무것도 없어서 i[0] = i[0]으로 둬야됨 --> i[0] = i[0] + i[-1] 의 값은 마지막꺼 더해버리니깐 안되겟지용
for i in range(1, len(x)):
    x[i] = x[i] + x[i-1]

print(sum(x))
```

---

## 분해합 - 백준 2231 문제

### 문제

어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.

어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.

예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다.

따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다.

반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.

### 입력

첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

### 출력

첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

### 예제

| 입력 1 | 출력 1 |
| ------ | ------ |
| 216    | 198    |

### 풀이

```python
n = int(input())  # 분해합을 입력값으로 받음

for i in range(1, n+1):   # 해당 분해합의 생성자 찾기
    num = sum((map(int, str(i))))  # i의 각 자릿수를 더함
    num = i + num  # 분해합 = 생성자 + 각 자릿수의 합
    # i가 작은 수부터 차례로 들어가므로 처음으로 분해합과 입력값이 같을때가 가장 작은 생성자를 가짐
    if num == n:
        print(i)
        break
    if i == n:  # 생성자 i와 입력값이 같다는 것은 생성자가 없다는 뜻
        print(0)
```
