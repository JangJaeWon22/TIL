# Algorithm TIL

## 다리 놓기 - 백준 1010 문제

### [문제]

재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다.

하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다.

강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다.

재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)

재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.)

재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다.

다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.

### [입력]

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.

### [출력]

각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.

### [풀이]

- m이 n보다 크기 떄문에 최대 연결할 수 있는 다리의 갯수 n개
- m개의 지역에 n개의 다리를 놓을 수 있는 경우의 수

> 공식 mCn = m! // (n! x (m-n)!)
>
> factorial 은 재귀 함수로 짜서 공식에 그대로 적용함.

```python
# 팩토리얼 사용
import sys
from math import factorial
input = sys.stdin.readline

n = int(input())

for _ in range(n):
    # a <= b 조건이 있음
    n, m = map(int, input().split())
    answer = factorial(m) // (factorial(n) * factorial(m-n))
    print(answer)

```

- 핵심 코드

```python
    #  mCn = m! // (n! x (m-n)!)
    answer = factorial(m) // (factorial(n) * factorial(m-n))
```

---

## 영화감독 숌 - 백준 1436 문제

### [문제]

666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다.
영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.

하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.

종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.

따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.

숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.

### [입력]

첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.

### [출력]

첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.

### [풀이]

# n 번째의 영화 이름

1 => 666,
2 => 1666,
3 => 2666,
4 => 3666,
...
6 => 5666,
7 => 6660,
8 => 6661,
9 => 6662,
10 => 6663,
11 => 6664

- 이런 식으로 증가...
- 처음에는 7번째가 6666, 8번째가 7666으로 짜서 s = (n-1) \* 1000 + 666 이런 식으로 짯다.. 멍청이였다.

- 다른 자료를 찾아보니 그냥 666이 들어가면 카운트를 해주고 n = cnt일 때 그 해당 숫자를 뽑아주면 되는 문제였다.

```python
import sys
input = sys.stdin.readline

n = int(input())

name = 666
cnt = 0
while(True):
    if "666" in str(name):
        cnt += 1
        if cnt == n:
            print(name)
            break

    name += 1
```

- 아직도 많이 부족하다고 느낀다.. 더 열심히 해야겠다.

---

## 블랙잭 - 백준 2798 문제

### [문제]

카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다.

카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다.

블랙잭은 카지노마다 다양한 규정이 있다.

한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.

김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다.

그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.

이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다.

블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.

N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.

### [입력]

첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.

합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.

### [출력]

첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다

### [풀이]

- 노가다 형식으로 풀자..
- 총 카드 3장을 골라야 되니깐 for문을 3번....
- for(0~n) for(1~n) for(2~n)
- 그중 M 값을 넘으면 안되니 조건도 걸어줘야됨
- result에 m보다 작거나 같은 수 중 가장 가까운 값을 저장 후 출력

```python
import sys
input = sys.stdin.readline

N, M = map(int, (input().split()))

a = list(map(int, input().split()))  # 카드 리스트

result = 0
Max = 0

for i in range(N):  # 0부터 N
    for j in range(i+1, N):  # 1부터 N
        for k in range(j+1, N):  # 2부터 N
            if a[i] + a[j] + a[k] > M:  # 3개의 값 더한것이 M보다 크다면 넘어감
                continue
            else:
                result = max(result, a[i] + a[j] + a[k])
print(result)


print(Max)
```

### 다른사람 풀이

- 신박하다 모듈을 이용해서 풀었다.

```python
from itertools import combinations

n, s = map(int, input().split())
cards = list(map(int, input().split()))
max_sum = 0

for c in combinations(cards, 3):
    if sum(c) <= s and sum(c) > max_sum:
        max_sum = sum(c)
print(max_sum)
```

itertools을 활용하여 푸는 법도 있다니 신기 했다.
