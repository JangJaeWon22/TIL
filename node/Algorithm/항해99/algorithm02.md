# Algorithm TIL

## 1. 베르트랑 공준 - 백준 4948번

#### 문제

베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.

이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.

예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)

자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.

#### 입력

입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.

입력의 마지막에는 0이 주어진다.

#### 출력

각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.

#### 풀이

```jsx
def isPrime(num):
    if num == 1:
        return True
    else:
        for i in range(2, int(num**0.5)+1):
            if num % i == 0:
                return False
        return True


li = list(range(2, 246912))
prime_li = []
for i in li:
    if isPrime(i):
        prime_li.append(i)


while True:
    cnt = 0
    n = int(input())
    if n == 0:
        break

    for i in prime_li:
        if n < i <= n*2:
            cnt += 1

    print(cnt)
```

해당 숫자를 입력하면 소수를 구하는 문제이다.
함정이 존재 했다...

입력에 보면 여러개의 테스트 케이스로 이뤄져있다.

이것 때문에 실패 한번 했다.

-> 테스트 시 미리 범위 내의 값에 대한 소수를 모두 구하고 범위 내의 소수 갯수만 카운트 해주면 된다.....

그리고... 출력을 보자...

각 테스트 케이스에 대해서, n 보다 크고, 2n보다 작거나 같은 소수의 갯수를 출력한다.

```jsx
 n < 소수 범위 <= 2n
```

하.. 문제를 잘 읽어 보자.. 항상!!!!

---

## 2. 더하기 싸이클 - 백준 1110번

#### 문제

0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.

26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.

위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.

N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.

#### 출력

첫째 줄에 N의 사이클 길이를 출력한다.

#### 풀이

```jsx
// 26 ->        2+6 = 8 ==>         68 -> 6+8 = 14 ==>        84 -> 8+4 ==>         12 -> 4+2 ==>         26
//                       1                          2                    3                     4
// N ->         x+y = z =>>         num -> x+y = z ==>      num -> x+y = z ==>      num -> x+y = z ==>    num = N
// 총 4번의 싸이클
```

위 과정을 생각으로 풀이를 해보자

```python
N = int(input())
cnt = 0
num = N

while True:
    x = num // 10
    y = num % 10
    z = (x + y) % 10
    num = (y * 10) + z
    cnt = cnt + 1
    if(num == N):
        break
print(cnt)
```

생각보다 간단..
ez..

---

## 3. 터렛 - 백준 1002번

#### 문제

조규현과 백승환은 터렛에 근무하는 직원이다.
하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.
이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다.
조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.
조규현의 좌표 (x1, y1)와 백승환의 좌표 (x2, y2)가 주어지고,
조규현이 계산한 류재명과의 거리 r1과 백승환이 계산한 류재명과의 거리 r2가 주어졌을 때,
류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.
한 줄에 x1, y1, r1, x2, y2, r2가 주어진다. x1, y1, x2, y2는 -10,000보다 크거나 같고,
10,000보다 작거나 같은 정수이고, r1, r2는 10,000보다 작거나 같은 자연수이다.

#### 출력

각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다.
만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.

#### 풀이

> 출처 : https://ooyoung.tistory.com/111

원의 방정식을 활용한 거리 구하는 문제....

이번 기회에 원의 방정식을 구하는 법을 배웠다...

- 터렛 2개의 좌표(x,y)와 터렛과 타깃까지의 거리(r)를 입력 받고 x1, y1, r1, x2, y2, r2 변수에 선언.
  두 터렛의 위치가 (x,y) 좌표로 각각 주어지기 때문에 두 터렛의 거리를 반지름으로 하는 원이 있다고 가정!!!
  원의 방정식을 활용해 두 터렛의 거리를 구한다.

```jsx
원의 방정식 = (x1-x2)**2 + (y1-y2)**2
```

- 중심거리와 두 원의 위치 관계식을 이용해 두 원의 접점 갯수를 알아낸다.

```python
    if distance == 0 and r1 == r2:  # 두 원이 동심원이고 반지름이 같을 때
        print(-1)
    elif abs(r1-r2) == distance or r1 + r2 == distance:  # 내접, 외접일 때
        print(1)
    elif abs(r1-r2) < distance < (r1+r2):  # 두 원이 서로다른 두 점에서 만날 때
        print(2)
    else:
        print(0)  # 그 외에
```

각 터렛에서 도출되는 두 원의 접점은 중심거리와 두 원의 위치 관계식을 조건문으로 표현.

- 중심거리와 두 원의 위치 관계
  반지름의 길이가 r1인 원과 r2인 원의 중심거리를 d라고 할 때, |r1 - r2| 또는 r1 + r2와의 크기를 비교해보면, 두 원의 위치 관계를 알 수 있다.

> r1 + r2 < d 이면 두 원은 서로의 외부에 위치한다.
>
> r1 + r2 = d 이면 두 원은 외접한다.
>
> |r1 - r2| < d < r1 + r2 이면 두 원은 서로 다른 두 점에서 만난다.
>
> |r1 - r2| = d 이면 한 원이 다른 원에 내접한다.
>
> |r1 - r2| > d, r1 ≠ r2 이면 한 원이 다른 원의 내부에 있다.

#### 전체 코드

```python
import math

n = int(input())

for _ in range(n):
    x1, y1, r1, x2, y2, r2 = map(int, input().split())
    distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)  # 두 원의 거리 (원의방정식활용)
    if distance == 0 and r1 == r2:  # 두 원이 동심원이고 반지름이 같을 때
        print(-1)
    elif abs(r1-r2) == distance or r1 + r2 == distance:  # 내접, 외접일 때
        print(1)
    elif abs(r1-r2) < distance < (r1+r2):  # 두 원이 서로다른 두 점에서 만날 때
        print(2)
    else:
        print(0)  # 그 외에
```

어렵다.. 너무 어렵다... 제대로 이해될때까지 계속 본다...

---

## 4. 설탕 배달 - 백준 2839번

#### 문제

상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.

상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.

상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)

#### 출력

상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.

#### 풀이

```python
sugar = int(input())

bag = 0
while sugar >= 0:
    if sugar % 5 == 0:  # 5의 배수이면 백의 갯수는 5를 나눈 값이 되고.
        bag += (sugar // 5)  # 5로 나눈 몫을 구해야 정수가 됨
        print(bag)
        break
    sugar -= 3  # 5의 배수가 될 때까지 설탕-3 // ex) 입력값 :18// 남은 설탕 15g 봉지 3g 1개  //  남은 설탕 0g 봉지는 3g 1개 + 5g 3개
    bag += 1  # , 봉지+1
else:
    print(-1)
```

- 5의 배수가 될때까지 3을 빼주고 3g 봉지가 늘어나니 bag = bag+1 처리를 해준다
- 5의 배수가 되면 if을 타고 들어가 나누어 주고 그 몫을 bag에 더해준다.
